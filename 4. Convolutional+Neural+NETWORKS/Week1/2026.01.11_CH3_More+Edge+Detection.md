# My Diary

Today  **{{DATE_PRETTY}}**.

## General Counter
It has been    **{{DAY_SINCE_2025_08_18}}** days since I started this diary.

# Repository Counter

Day **{{DAYS_SINCE_REPO_START}}** From I started this repository


# More Edge Detection: Positive/Negative Edges & Learning Filters

## 1. Positive vs. Negative Edges
The convolution operation doesn't just find an edge; it tells you the **direction** of the transition (Light $\to$ Dark vs. Dark $\to$ Light).

* **Positive Edge (Light $\to$ Dark):** If you transition from bright pixels (10) to dark pixels (0), the convolution output is positive (e.g., $+30$).
* **Negative Edge (Dark $\to$ Light):** If you transition from dark pixels (0) to bright pixels (10), the convolution output is negative (e.g., $-30$).
* *Note:* If you don't care about the direction, you can simply take the absolute value of the output matrix.


## 2. Horizontal Edge Detection
To detect horizontal lines (like a horizon or a railing), you simply rotate the vertical filter by 90 degrees.

**The Horizontal Filter:**
```math
$$
\begin{bmatrix}
1 & 1 & 1 \\
0 & 0 & 0 \\
-1 & -1 & -1
\end{bmatrix}
$$
```
* This looks for differences between the **top row** and the **bottom row**.


## 3. Hand-Coded Filter Variations
Before Deep Learning, computer vision researchers debated the "best" numbers to put in these filters to make them robust. Two famous examples are:

* **Sobel Filter:** Put more weight on the central row (1, 2, 1) to make it more robust.
```math
    $$
    \begin{bmatrix}
    1 & 0 & -1 \\
    2 & 0 & -2 \\
    1 & 0 & -1
    \end{bmatrix}
    $$
```
* **Scharr Filter:** Uses even stronger weights (3, 10, 3).
```math
    $$
    \begin{bmatrix}
    3 & 0 & -3 \\
    10 & 0 & -10 \\
    3 & 0 & -3
    \end{bmatrix}
    $$

```
## 4. The Deep Learning Approach: Learning the Filter
Instead of hand-picking these numbers (1, 0, -1 vs. 3, 10, -3), we can let the neural network **learn** them.

* **The Idea:** Treat the 9 numbers in the $3 \times 3$ filter as **parameters** ($w_1, w_2, \dots, w_9$) just like weights in a standard neural network.
* **The Process:** Use **Backpropagation** to learn the optimal values for these 9 numbers based on the data.
* **The Benefit:** The network isn't limited to just vertical or horizontal edges. It can learn to detect edges at **45 degrees**, **70 degrees**, or any specific feature that helps minimize the loss function. This is significantly more robust than human-coded filters.

## Implementation

```python 
import numpy as np

def convolve_2d(image, filter_kernel):
    """
    Performs a valid 2D convolution between an image and a filter.
    filter_kernel --> represent the weight
    region --> represent x 
    """
    h_img, w_img = image.shape
    h_filter, w_filter = filter_kernel.shape
    
    # Calculate output dimensions (n - f + 1)
    h_out = h_img - h_filter + 1
    w_out = w_img - w_filter + 1
    
    output = np.zeros((h_out, w_out))
    
    # Slide the filter over the image
    for i in range(h_out):
        for j in range(w_out):
            # Extract the region of interest (ROI)
            region = image[i:i+h_filter, j:j+w_filter]
            # Perform element-wise multiplication and sum
            output[i, j] = np.sum(region * filter_kernel)
            
    return output

# ==========================================
# Example 1: The Specific Calculation (Math Check)
# ==========================================
print("--- Example 1: Specific Math Check ---")
# The 6x6 input matrix from the video/text
input_matrix = np.array([
    [3, 0, 1, 2, 7, 4],
    [1, 5, 8, 9, 3, 1],
    [2, 7, 2, 5, 1, 3],
    [0, 1, 3, 1, 7, 8],
    [4, 2, 1, 6, 2, 8],
    [2, 4, 5, 2, 3, 9]
])

# The Vertical Edge Filter (3x3)
vertical_filter = np.array([
    [1, 0, -1],
    [1, 0, -1],
    [1, 0, -1]
])

result_1 = convolve_2d(input_matrix, vertical_filter)

print("Input (Top-Left 3x3 subset):")
print(input_matrix[:3, :3])
print("\nFilter:")
print(vertical_filter)
print("\nCalculation for first pixel: (3*1 + 0*0 + 1*-1) + (1*1 + 5*0 + 8*-1) + (2*1 + 7*0 + 2*-1)")
print(f"Expected Result: -5")
print(f"Actual Computed Result (Top-Left pixel): {result_1[0,0]}")
print("\nFull Output Matrix (4x4):")
print(result_1)


# ==========================================
# Example 2: Vertical Edge Detection Intuition
# ==========================================
print("\n\n--- Example 2: Vertical Edge Detection (10s and 0s) ---")
# Create 6x6 image: Left half 10, Right half 0
image_vertical = np.zeros((6, 6))
image_vertical[:, :3] = 10

print("Input Image (Simplified):")
print(image_vertical)

# Apply the same vertical filter
result_vertical = convolve_2d(image_vertical, vertical_filter)

print("\nOutput (Detecting the vertical edge in the center):")
print(result_vertical)
# You will see '30's in the middle, indicating a strong positive vertical edge.


# ==========================================
# Example 3: Horizontal Edge Detection
# ==========================================
print("\n\n--- Example 3: Horizontal Edge Detection ---")
# Create 6x6 image: Top half 10, Bottom half 0
image_horizontal = np.zeros((6, 6))
image_horizontal[:3, :] = 10

# Create Horizontal Filter (Rotated 90 degrees)
horizontal_filter = np.array([
    [1, 1, 1],
    [0, 0, 0],
    [-1, -1, -1]
])

print("Input Image (Horizontal Split):")
print(image_horizontal)
print("\nHorizontal Filter:")
print(horizontal_filter)

# Apply horizontal filter
result_horizontal = convolve_2d(image_horizontal, horizontal_filter)

print("\nOutput (Detecting the horizontal edge):")
print(result_horizontal)


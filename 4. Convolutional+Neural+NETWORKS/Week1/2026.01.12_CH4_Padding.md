# My Diary

Today  **Saturday, 17 Jan 2026**.

## General Counter
It has been    **153** days since I started this diary.

# Repository Counter

Day **25** From I started this repository


# CNN Basics: Padding

## 1. The Problem with Basic Convolutions
When you perform a standard convolution (like applying a $3 \times 3$ filter to a $6 \times 6$ image), two issues arise:

1.  **Shrinking Output:** The image gets smaller with every layer.
    * $6 \times 6 \text{ Image} * 3 \times 3 \text{ Filter} \rightarrow 4 \times 4 \text{ Output}$.
    * *Formula:* $(n - f + 1) \times (n - f + 1)$.
    * If you have a deep network with 100 layers, your image will shrink to $1 \times 1$ very quickly, losing spatial structure.
2.  **Loss of Edge Information:** Pixels on the corners/edges are used much less than pixels in the center.
    * A center pixel is overlapped by many filter positions.
    * A corner pixel is only touched once. This means you are "throwing away" information from the edges of the image.


## 2. The Solution: Padding
To fix this, we pad the image with an extra border of pixels (usually zeros) before convolving.

* **Input:** $6 \times 6$ Image.
* **Pad ($p=1$):** Add a 1-pixel border all around $\rightarrow$ New size is $8 \times 8$.
* **Convolution:** Apply $3 \times 3$ filter to the $8 \times 8$ padded image.
* **Output:** $6 \times 6$.
    * *Math:* $(n + 2p - f + 1) \times (n + 2p - f + 1)$.
    * $(6 + 2(1) - 3 + 1) = 6$.
* **Result:** The output size equals the original input size, and corner pixels are now used more often.

## 3. Valid vs. Same Convolutions
In Deep Learning frameworks (like TensorFlow/PyTorch), you often specify padding using one of two keywords:

| Type | Definition | Formula for Output Size |
| :--- | :--- | :--- |
| **"Valid"** | No padding ($p=0$). The image shrinks. | $n - f + 1$ |
| **"Same"** | Pad so that Output Size = Input Size. | $n$ |

**How to calculate Padding ($p$) for "Same" convolution:**
To keep the output size $n$ equal to the input size $n$:
$$n + 2p - f + 1 = n$$
$$2p = f - 1$$
$$p = \frac{f - 1}{2}$$
* *Note:* This works best when filter size $f$ is **odd** (e.g., 3, 5, 7), which is standard in Computer Vision.


## 4. Implementation & Relation to Previous Concepts
### Relation to Edge Detection
In the previous section, we saw how a $3 \times 3$ filter detects edges. Without padding, applying that filter to a $6 \times 6$ image resulted in a $4 \times 4$ map of edges.
* By adding **Padding**, we ensure that our "Edge Map" has the same resolution ($6 \times 6$) as the original photo, preserving the spatial location of edges exactly where they were.

### Python Implementation (Concept)
```python
import numpy as np

def zero_pad(X, pad):
    """
    Pad with zeros all images of the dataset X.
    """
    # np.pad pads the array. ((0,0), (pad,pad), (pad,pad), (0,0)) pads the 
    # height and width dimensions (dim 1 and 2) with 'pad' zeros.
    X_pad = np.pad(X, ((0, 0), (pad, pad), (pad, pad), (0, 0)), 
                   'constant', constant_values=0)
    return X_pad

# Example:
# If input X is (m, 6, 6, 3) and pad = 1
# X_pad will be (m, 8, 8, 3)
# Then convolution reduces it back to (m, 6, 6, filters)

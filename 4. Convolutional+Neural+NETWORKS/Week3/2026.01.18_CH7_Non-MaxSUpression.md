# My Diary

Today  **Monday, 19 Jan 2026**.

## General Counter
It has been    **155** days since I started this diary.

# Repository Counter

Day **27** From I started this repository


# Non-max Suppression (NMS)

## 1. The Problem: Multiple Detections
In an ideal world, only one grid cell (the one containing the midpoint) would detect an object. In reality, multiple grid cells often claim to have found the same object.
* **Result:** You end up with 3 or 4 bounding boxes for a single car, cluttering the output.
* **Goal:** We want to keep only the *best* bounding box and discard the redundant ones.


## 2. The Solution: Non-max Suppression Algorithm
The algorithm works by greedily picking the highest confidence box and suppressing (deleting) any other boxes that overlap significantly with it.

### The Algorithm Steps:
1.  **Filter:** Discard all boxes with object probability $p_c \le 0.6$ (or some threshold).
2.  **Loop:** While there are remaining boxes:
    * **Pick Max:** Select the box with the highest probability $p_c$ and output it as a prediction.
    * **Suppress:** Compare this box with all other remaining boxes. If any remaining box has a high **IoU (Intersection over Union)** (e.g., $\ge 0.5$) with the selected box, discard it.
    * *Intuition:* If two boxes overlap heavily, they are likely detecting the same object. Since we already picked the one with the highest confidence, the other one is redundant.


## 3. Multiple Classes
If you are detecting multiple classes (e.g., cars AND pedestrians):
* You run Non-max Suppression **independently** for each class.
* Run NMS on all "Car" detections.
* Then run NMS on all "Pedestrian" detections.

## 4. Relation to Earlier Concepts
* **IoU:** NMS relies entirely on the Intersection Over Union metric we defined in the previous section to decide which boxes are "overlapping enough" to be suppressed.
* **YOLO:** The raw output of YOLO is a grid of many potential boxes. NMS is the standard "cleanup" layer that turns that raw grid into a clean list of unique objects.

## 5. Basic Chunk Implementation (NMS Logic)
This snippet shows the core logic of NMS using PyTorch's built-in utility, which is highly optimized.

```python
import torch
import torchvision.ops as ops

def apply_nms(boxes, scores, iou_threshold=0.5):
    """
    boxes: Tensor of shape (N, 4) -> [x1, y1, x2, y2]
    scores: Tensor of shape (N,) -> Confidence scores (pc)
    """
    # torchvision.ops.nms performs the exact algorithm described:
    # 1. Sorts by score
    # 2. Picks max
    # 3. Suppresses overlaps > threshold
    keep_indices = ops.nms(boxes, scores, iou_threshold)
    
    return boxes[keep_indices], scores[keep_indices]

# My Diary

Today  **{{DATE_PRETTY}}**.

## General Counter
It has been    **{{DAY_SINCE_2025_08_18}}** days since I started this diary.

# Repository Counter

Day **{{DAYS_SINCE_REPO_START}}** From I started this repository

# Landmark Detection

## 1. What is Landmark Detection?
In the previous section, we learned to output a bounding box (4 numbers) to localize a general object.
**Landmark Detection** generalizes this idea: instead of a box, we ask the neural network to output specific **(x, y) coordinates** for key points (landmarks) on the object.

**Examples:**
* **Face Recognition:** Finding the corners of the eyes, mouth, or jawline.
* **Pose Estimation:** Finding the position of shoulders, elbows, and knees.


## 2. Defining Landmarks
To detect landmarks, you simply increase the number of output units in your final layer.

* **Example: Face Landmarks**
    * Let's say you want 64 landmarks (eye corners, nose tip, mouth edges, etc.).
    * Each landmark has 2 coordinates: $(l_{1x}, l_{1y}), (l_{2x}, l_{2y}), ..., (l_{64x}, l_{64y})$.
    * **Output Vector:** $129$ units total.
        * 1 unit: Is there a face? ($0$ or $1$).
        * 128 units: The 64 coordinate pairs ($64 \times 2$).

## 3. Applications
* **Augmented Reality (AR):** Snapchat filters (e.g., dog ears, crowns) work by detecting these face landmarks and warping graphics to match the coordinates.
* **Emotion Recognition:** Analyzing the shape of the mouth (smile vs. frown) and eyebrows.
* **Pose Detection:** Analyzing a person's posture for sports analytics or gaming.

## 4. Consistency is Key
For this to work, the labels must be **consistent** across the entire training set.
* **Landmark 1** must *always* be the "left corner of the left eye."
* **Landmark 2** must *always* be the "right corner of the left eye," and so on.
* You cannot label them randomly; the network learns the specific semantic meaning of each output neuron.

## 5. Relation to Earlier Concepts
* **Regression:** Just like bounding box prediction ($b_x, b_y$), landmark detection is a pure regression problem. We are predicting continuous real numbers (coordinates) rather than class labels.
* **ConvNets:** The backbone is still a standard ConvNet (like VGG or ResNet). The only change is the final Fully Connected layer, which is sized to output $2 \times N_{landmarks}$ instead of $N_{classes}$.

## 6. Basic Chunk Implementation (Landmark Head)
This snippet shows how to define the final layer for a landmark detection model.

```python
import torch.nn as nn

class LandmarkNet(nn.Module):
    def __init__(self, num_landmarks=68):
        super().__init__()
        # ... (Conv layers defined here) ...
        self.features = nn.Sequential(...) 
        
        # Final Regression Head
        # Output size = num_landmarks * 2 (x and y for each)
        self.regressor = nn.Linear(512 * 7 * 7, num_landmarks * 2) 

    def forward(self, x):
        x = self.features(x)
        x = x.view(x.size(0), -1) # Flatten
        coords = self.regressor(x) # Output: [Batch, 136]
        return coords

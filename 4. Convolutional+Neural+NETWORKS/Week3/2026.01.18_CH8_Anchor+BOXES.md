# My Diary

Today  **Monday, 19 Jan 2026**.

## General Counter
It has been    **155** days since I started this diary.

# Repository Counter

Day **27** From I started this repository

# Anchor Boxes

## 1. The Problem: Overlapping Objects
In standard YOLO, each grid cell can output only **one** detection.
* **Scenario:** Imagine a pedestrian standing directly in front of a car. The midpoint of the person and the midpoint of the car might fall into the **same grid cell**.
* **Failure:** The network is forced to choose just one object to detect, missing the other.


## 2. The Solution: Pre-defined Shapes
We define a set of fixed shapes called **Anchor Boxes** (e.g., Anchor 1 is tall/skinny, Anchor 2 is wide/fat).
* **New Assignment Rule:** An object is assigned to the grid cell containing its midpoint **AND** the anchor box that has the highest **IoU** with the object's shape.
    * *Pedestrian (Tall):* Assigned to (Grid Cell, Anchor 1).
    * *Car (Wide):* Assigned to (Grid Cell, Anchor 2).
* **Result:** A single grid cell can now output two predictions: one for the "Tall" slot and one for the "Wide" slot.


## 3. The Output Dimensions
The output vector $y$ repeats to accommodate the anchors.
If we use **2 Anchor Boxes** and detecting 3 classes ($c_1, c_2, c_3$):
* **Single Anchor Vector:** $[p_c, b_x, b_y, b_h, b_w, c_1, c_2, c_3]$ (8 units).
* **Two Anchor Vectors:** We stack them. Total depth = 16 units.
* **Output Volume:** $S \times S \times (B \times (5 + C))$
    * $S$: Grid size (e.g., 19).
    * $B$: Number of anchors (e.g., 2 or 5).
    * $C$: Number of classes.
    * Example: $19 \times 19 \times (2 \times 8) = 19 \times 19 \times 16$.

## 4. Why it Helps (Specialization)
Even if objects rarely overlap in a fine $19 \times 19$ grid, anchor boxes are still crucial. They allow the network to **specialize**.
* Some outputs become experts at detecting tall things (pedestrians).
* Other outputs become experts at detecting wide things (cars).
* This makes training easier and more stable.

## 5. Relation to Earlier Concepts
* **IoU:** We use the Intersection Over Union metric (defined in the previous section) not just for evaluation, but *during training* to decide which anchor box "claims" the ground truth object.
* **YOLO:** This is the final piece of the YOLO puzzle. The full algorithm is Grid + Conv Implementation + Anchor Boxes.

## 6. Basic Chunk Implementation (Choosing the Best Anchor)
This snippet demonstrates the logic used during training to assign a ground truth object to the correct anchor.

```python
def get_best_anchor(obj_h, obj_w, anchors):
    """
    obj_h, obj_w: Height and width of the ground truth object
    anchors: List of (h, w) tuples for anchor boxes
    Returns: Index of the anchor with highest IoU
    """
    best_iou = -1
    best_anchor_idx = -1
    
    # Object box (centered at 0,0 for comparison)
    obj_area = obj_h * obj_w
    
    for i, (anc_h, anc_w) in enumerate(anchors):
        # Calculate IoU assuming centers are aligned
        # Intersection is the min dimensions
        inter_h = min(obj_h, anc_h)
        inter_w = min(obj_w, anc_w)
        inter_area = inter_h * inter_w
        
        anc_area = anc_h * anc_w
        union_area = obj_area + anc_area - inter_area
        
        iou = inter_area / union_area
        
        if iou > best_iou:
            best_iou = iou
            best_anchor_idx = i
            
    return best_anchor_idx
